import pandas as pd
import argparse
import html
import os
import sqlite3
from datetime import date, timedelta, datetime

# Security Note: The HTML is generated by embedding data directly. 
# While the data (URLs, paths, statuses) is generally from crawling trusted sites or self-generated,
# for broader applications, using a templating engine (like Jinja2) would be a safer practice 
# to prevent potential XSS if data sources were less controlled.

def generate_html_table_from_df(df, table_id):
    """Generates an HTML table string from a pandas DataFrame for use with DataTables."""
    if df.empty:
        return f"<p>No data available for {table_id.replace('Table', '')}.</p>"

    table_html = f'''
    <table id="{table_id}" class="display" style="width:100%">
        <thead>
            <tr>{''.join(f'<th>{col}</th>' for col in df.columns)}</tr>
            <tr class="filters">{''.join("<th><input type='text' placeholder='Filter ...' style='width: 90%;' /></th>" for _ in df.columns)}</tr>
        </thead>
        <tbody>
'''
    for _, row in df.iterrows():
        status_val = row.get("Status", "N/A") # Get status, default to N/A if not present
        try:
            status = int(float(status_val)) if pd.notna(status_val) else 0
        except ValueError:
            status = 0 # Default for non-integer statuses

        cls = "ok" if status == 200 else "redirect" if 300 <= status < 400 else "error"
        table_html += f"<tr class='{cls}'>"
        for col, val in row.items():
            # Ensure HTML special characters in data are escaped to prevent XSS. Pandas to_html does this by default.
            # Here, we are manually creating cells, so care is needed. For URLs, it's common to allow them as hrefs.
            # For other text, escaping would be important if it could come from untrusted input.
            # Given the source of this data, direct embedding is lower risk but not best practice.
            escaped_val = html.escape(str(val))
            if col == "URL":
                table_html += f"<td><a href='{escaped_val}' target='_blank'>{escaped_val}</a></td>"
            else:
                table_html += f"<td>{escaped_val}</td>"
        table_html += "</tr>"
    table_html += """
        </tbody>
    </table>
"""
    return table_html

STYLE_DEFINITIONS = """
            :root {
                --container-max: 1400px;
                --brand: #0d6efd;
                --muted-bg: #f6f7f9;
                --muted: #6c757d;
                --card-bg: #ffffff;
                --border: #e5e7eb;
            }
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                margin: 0;
                background-color: var(--muted-bg);
                color: #1f2937;
            }
            header {
                background: linear-gradient(180deg, #fff, #fafbfc);
                border-bottom: 1px solid var(--border);
                padding: 24px 16px 16px;
                margin-bottom: 16px;
            }
            h1 {
                text-align: center;
                margin: 0 auto;
                max-width: var(--container-max);
                font-weight: 700;
                letter-spacing: .2px;
            }
            .container {
                max-width: var(--container-max);
                margin: 0 auto;
                padding: 0 16px 24px;
            }
            .summary-container {
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                margin-bottom: 16px;
            }
            .summary-item {
                background-color: #eef2f7;
                padding: 10px 14px;
                border-radius: 999px;
                font-size: 14px;
                border: 1px solid var(--border);
            }
            .tab-container {
                margin-top: 12px;
                background-color: var(--card-bg);
                padding: 0 0 16px;
                border-radius: 12px;
                box-shadow: 0 6px 18px rgba(0,0,0,0.06);
                border: 1px solid var(--border);
            }
            .tab-buttons {
                display: flex;
                gap: 12px;
                padding: 12px;
                border-bottom: 1px solid var(--border);
                background: #fff;
                position: sticky;
                top: 0;
                z-index: 10;
            }
            .tab-link {
                background-color: #f3f4f6;
                border: 1px solid var(--border);
                padding: 12px 24px;
                cursor: pointer;
                border-radius: 10px;
                font-weight: 700;
                font-size: 15px;
                letter-spacing: .2px;
                min-width: 160px;
                transition: all .15s ease;
            }
            .tab-link.active, .tab-link:hover {
                background-color: #e9effe;
                border-color: #c2d3ff;
                color: #0b3fbf;
            }
            .tab-content {
                display: none;
                padding: 16px;
            }
            .card {
                background: #fff;
                border: 1px solid var(--border);
                border-radius: 10px;
                padding: 14px;
                box-shadow: 0 2px 10px rgba(0,0,0,.04);
            }
            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 10px;
                background: #fff;
                border-radius: 8px;
                overflow: hidden;
            }
            th, td {
                text-align: left;
                padding: 10px 12px;
                border-bottom: 1px solid #eee;
            }
            th {
                background-color: #f8fafc;
                color: #111827;
            }
            .download-button {
                display: inline-block;
                margin: 10px 0;
                padding: 10px 15px;
                background-color: var(--brand);
                color: white;
                text-decoration: none;
                border-radius: 6px;
            }
            .download-button:hover { filter: brightness(.95); }
            #scrollTopBtn, #scrollBottomBtn {
                position: fixed;
                right: 20px;
                padding: 10px;
                font-size: 18px;
                border: none;
                border-radius: 8px;
                background-color: var(--brand);
                color: white;
                cursor: pointer;
                z-index: 1000;
                box-shadow: 0 6px 16px rgba(0,0,0,0.15);
            }
            #scrollTopBtn { bottom: 80px; }
            #scrollBottomBtn { bottom: 24px; }
            .download-tab-button {
                display: inline-block;
                padding: 8px 12px;
                background-color: #6c757d;
                color: white;
                text-decoration: none;
                border-radius: 999px;
                margin-left: 10px;
                font-size: 12px;
                border: 1px solid var(--border);
            }
            .download-tab-button:hover { filter: brightness(.95); }
"""

def _connect_db(db_path: str = 'broken_links.db'):
    conn = sqlite3.connect(db_path)
    return conn

def _ensure_retention(conn: sqlite3.Connection, keep_days: int = 60):
    cur = conn.cursor()
    cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'broken_links_%';")
    tables = [r[0] for r in cur.fetchall()]
    cutoff = date.today() - timedelta(days=keep_days)
    for t in tables:
        try:
            d_str = t.replace('broken_links_', '')
            d = datetime.strptime(d_str, '%Y_%m_%d').date()
        except Exception:
            continue
        if d < cutoff:
            cur.execute(f'DROP TABLE IF EXISTS {t}')
    conn.commit()

def _store_broken_links_today(conn: sqlite3.Connection, df: pd.DataFrame):
    # df expected columns include Region, URL, Status, Path, Visible, Timestamp
    today_str = date.today().strftime('%Y_%m_%d')
    table = f"broken_links_{today_str}"
    cur = conn.cursor()
    cur.execute(f"""
        CREATE TABLE IF NOT EXISTS {table} (
            Region TEXT,
            URL TEXT,
            Status INTEGER,
            Path TEXT,
            Visible TEXT,
            Timestamp TEXT
        )
    """)
    # Insert rows
    records = df[df['Status'] >= 400][['Region','URL','Status','Path','Visible','Timestamp']].to_records(index=False)
    cur.executemany(
        f"INSERT INTO {table} (Region, URL, Status, Path, Visible, Timestamp) VALUES (?,?,?,?,?,?)",
        list(records)
    )
    conn.commit()

def _load_broken_set(conn: sqlite3.Connection, target_date: date) -> set[tuple[str, str]]:
    table = f"broken_links_{target_date.strftime('%Y_%m_%d')}"
    cur = conn.cursor()
    try:
        cur.execute(f"SELECT Region, URL FROM {table}")
    except sqlite3.OperationalError:
        return set()
    return set(cur.fetchall())

def _compute_changes(conn: sqlite3.Connection):
    today_d = date.today()
    yday_d = today_d - timedelta(days=1)
    week_d = today_d - timedelta(days=7)
    today_set = _load_broken_set(conn, today_d)
    yday_set = _load_broken_set(conn, yday_d)
    week_set = _load_broken_set(conn, week_d)
    # Added = in today but not in past; Removed = in past but not in today
    y_added = sorted(list(today_set - yday_set))
    y_removed = sorted(list(yday_set - today_set))
    w_added = sorted(list(today_set - week_set))
    w_removed = sorted(list(week_set - today_set))
    return {
        'yesterday': {'added': y_added, 'removed': y_removed},
        'week': {'added': w_added, 'removed': w_removed}
    }

def generate_combined_html_report(au_csv_path, nz_csv_path, output_html_path='combined_report.html', db_path: str = 'broken_links.db'):
    """Generates a combined HTML report with tabs for AU and NZ link check results."""
    try:
        au_df = pd.read_csv(au_csv_path)
        au_df['Status'] = pd.to_numeric(au_df['Status'], errors='coerce').fillna(0).astype(int)
    except FileNotFoundError:
        print(f"Warning: AU results file not found at {au_csv_path}. AU tab will be empty.")
        au_df = pd.DataFrame(columns=['URL', 'Status', 'Path', 'Visible'])
    except Exception as e:
        print(f"Error reading AU CSV {au_csv_path}: {e}")
        au_df = pd.DataFrame(columns=['URL', 'Status', 'Path', 'Visible'])

    try:
        nz_df = pd.read_csv(nz_csv_path)
        nz_df['Status'] = pd.to_numeric(nz_df['Status'], errors='coerce').fillna(0).astype(int)
    except FileNotFoundError:
        print(f"Warning: NZ results file not found at {nz_csv_path}. NZ tab will be empty.")
        nz_df = pd.DataFrame(columns=['URL', 'Status', 'Path', 'Visible'])
    except Exception as e:
        print(f"Error reading NZ CSV {nz_csv_path}: {e}")
        nz_df = pd.DataFrame(columns=['URL', 'Status', 'Path', 'Visible'])

    # Add region column before combining
    au_df['Region'] = 'AU'
    nz_df['Region'] = 'NZ'

    # Combine dataframes for the combined CSV download
    combined_df = pd.concat([au_df, nz_df], ignore_index=True)
    # Reorder columns to have Region first, then Timestamp, then others
    cols = ['Region', 'Timestamp'] + [col for col in combined_df.columns if col not in ['Region', 'Timestamp']]
    combined_df = combined_df[cols]
    combined_csv_path = 'combined_link_check_results.csv'
    # combined_df.to_csv(combined_csv_path, index=False) # Removed generation of combined CSV
    # print(f"✅ Combined CSV report saved to {combined_csv_path}")

    total_links_au = len(au_df[au_df['Region'] == 'AU']) # Filter by region just in case, though au_df is already AU
    broken_links_au = len(au_df[(au_df['Region'] == 'AU') & (au_df['Status'] >= 400)])
    total_links_nz = len(nz_df[nz_df['Region'] == 'NZ'])
    broken_links_nz = len(nz_df[(nz_df['Region'] == 'NZ') & (nz_df['Status'] >= 400)])

    # Create filtered dataframes for HTML tables (only errors)
    # The original au_df and nz_df are used for overall summary statistics
    au_error_df = au_df[au_df['Status'] >= 400].copy()
    nz_error_df = nz_df[nz_df['Status'] >= 400].copy()

    # Persist today's broken links to SQLite and enforce retention
    try:
        conn = _connect_db(db_path)
        _ensure_retention(conn, keep_days=60)
        # Merge for storage to avoid two passes
        merged_err_df = pd.concat([au_error_df, nz_error_df], ignore_index=True)
        # Ensure required columns exist
        for col in ['Timestamp','Region','URL','Status','Path','Visible']:
            if col not in merged_err_df.columns:
                merged_err_df[col] = ''
        _store_broken_links_today(conn, merged_err_df)
        changes = _compute_changes(conn)
        # Build a single combined CSV: Region, URL, Change, Window
        combined_rows = []
        for reg, url in changes['yesterday']['added']:
            combined_rows.append({"Region": reg, "URL": url, "Change": "Added", "Window": "Yesterday"})
        for reg, url in changes['yesterday']['removed']:
            combined_rows.append({"Region": reg, "URL": url, "Change": "Removed", "Window": "Yesterday"})
        for reg, url in changes['week']['added']:
            combined_rows.append({"Region": reg, "URL": url, "Change": "Added", "Window": "Last 7 Days"})
        for reg, url in changes['week']['removed']:
            combined_rows.append({"Region": reg, "URL": url, "Change": "Removed", "Window": "Last 7 Days"})
        try:
            pd.DataFrame(combined_rows, columns=["Region","URL","Change","Window"]).to_csv('changes_all.csv', index=False)
        except Exception as e:
            print(f"Failed to write combined changes CSV: {e}")
    finally:
        try:
            conn.close()
        except Exception:
            pass

    # Generate HTML tables using the filtered error dataframes
    # Drop 'Region' for individual table view; errors='ignore' handles cases where 'Region' might not exist (e.g., empty df)
    au_table_html = generate_html_table_from_df(au_error_df.drop(columns=['Region'], errors='ignore'), 'auLinkTable')
    nz_table_html = generate_html_table_from_df(nz_error_df.drop(columns=['Region'], errors='ignore'), 'nzLinkTable')

    # Build Changes tab HTML
    def render_changes_section(title: str, items: list[tuple[str,str]]):
        # items: list of (Region, URL)
        if not items:
            return "<p>No changes.</p>"
        rows = ''.join([f"<tr><td>{html.escape(reg)}</td><td><a href='{html.escape(url)}' target='_blank'>{html.escape(url)}</a></td></tr>" for reg, url in items])
        return f"""
            <table class='display' style='width:100%'>
                <thead><tr><th>Region</th><th>URL</th></tr></thead>
                <tbody>{rows}</tbody>
            </table>
        """

    changes_html = f"""
        <div id="Changes" class="tab-content">
            <h2>Changes since Yesterday</h2>
            <div class="summary-container">
                <span class="summary-item">➕ Added: {len(changes['yesterday']['added'])}</span>
                <span class="summary-item">➖ Removed: {len(changes['yesterday']['removed'])}</span>
                <span class="summary-item"><a class=\"download-tab-button\" download href=\"changes_all.csv\">Download All Changes (CSV)</a></span>
            </div>
            <h3>Added</h3>
            {render_changes_section('Added Yesterday', changes['yesterday']['added'])}
            <h3>Removed</h3>
            {render_changes_section('Removed Yesterday', changes['yesterday']['removed'])}

            <h2 style='margin-top:20px;'>Changes vs 7 Days Ago</h2>
            <div class="summary-container">
                <span class="summary-item">➕ Added: {len(changes['week']['added'])}</span>
                <span class="summary-item">➖ Removed: {len(changes['week']['removed'])}</span>
                <span class="summary-item"><a class=\"download-tab-button\" download href=\"changes_all.csv\">Download All Changes (CSV)</a></span>
            </div>
            <h3>Added</h3>
            {render_changes_section('Added Week', changes['week']['added'])}
            <h3>Removed</h3>
            {render_changes_section('Removed Week', changes['week']['removed'])}
        </div>
    """

    html_content = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Broken Link Report</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css">
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
        <style>
            {STYLE_DEFINITIONS}
        </style>
    </head>
    <body>
        <button onclick="scrollToTop()" id="scrollTopBtn" title="Go to top">&#x2191;</button> <!-- Up arrow -->
        <button onclick="scrollToBottom()" id="scrollBottomBtn" title="Go to bottom">&#x2193;</button> <!-- Down arrow -->
        <header>
            <h1>Kmart Link Check Report</h1>
        </header>
        <div class="container">
        <!-- <a href="combined_link_check_results.csv" download class="download-button">Download Combined CSV</a> --> <!-- Removed combined CSV download link -->

        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-link active" onclick="openTab(event, 'AU_Report')">AU</button>
                <button class="tab-link" onclick="openTab(event, 'NZ_Report')">NZ</button>
                <button class="tab-link" onclick="openTab(event, 'Changes')">Changes</button>
            </div>

            <div id="AU_Report" class="tab-content" style="display: block;">
                <div class="summary-container">
                    <span class="summary-item">🔍 Total Links Checked (AU): {total_links_au}</span>
                    <span class="summary-item">❌ Broken Links (AU): {broken_links_au}</span>
                    <span class="summary-item">✅ Valid Links (AU): {total_links_au - broken_links_au}</span>
                    <span class="summary-item"><a href="au_link_check_results.csv" download class="download-tab-button">Download AU Full CSV</a></span>
                </div>
                {au_table_html}
            </div>

            <div id="NZ_Report" class="tab-content">
                <div class="summary-container">
                    <span class="summary-item">🔍 Total Links Checked (NZ): {total_links_nz}</span>
                    <span class="summary-item">❌ Broken Links (NZ): {broken_links_nz}</span>
                    <span class="summary-item">✅ Valid Links (NZ): {total_links_nz - broken_links_nz}</span>
                    <span class="summary-item"><a href="nz_link_check_results.csv" download class="download-tab-button">Download NZ Full CSV</a></span>
                </div>
                {nz_table_html}
            </div>
            {changes_html}
        </div>
        </div>

        <script>
            function openTab(evt, reportName) {{
                var i, tabcontent, tablinks;
                tabcontent = document.getElementsByClassName("tab-content");
                for (i = 0; i < tabcontent.length; i++) {{
                    tabcontent[i].style.display = "none";
                }}
                tablinks = document.getElementsByClassName("tab-link");
                for (i = 0; i < tablinks.length; i++) {{
                    tablinks[i].className = tablinks[i].className.replace(" active", "");
                }}
                document.getElementById(reportName).style.display = "block";
                evt.currentTarget.className += " active";
            }}

            $(document).ready(function() {{
                ['#auLinkTable', '#nzLinkTable'].forEach(function(tableId) {{
                    if (!$(tableId).length) return; // If table doesn't exist, skip

                    var table = $(tableId).DataTable({{
                        pageLength: 100,
                        orderCellsTop: true,
                        fixedHeader: true,
                        initComplete: function () {{
                            var api = this.api();
                            // Check for the correct number of filterable columns (Timestamp, URL, Status, Path, Visible)
                            var filterHeaderCells = $(tableId + ' thead tr.filters th');
                            if (filterHeaderCells.length !== 5) {{
                                console.error('Expected 5 filterable columns for ' + tableId + ', found ' + filterHeaderCells.length + '. Skipping filter setup.');
                                return;
                            }}

                            api.columns().eq(0).each(function (colIdx) {{
                                // Get the input element for the current column's filter
                                var inputElement = $(filterHeaderCells[colIdx]).find('input');
                                
                                $(inputElement)
                                    .off('keyup change') // Remove previous event handlers to prevent duplicates
                                    .on('keyup change', function (e) {{
                                        e.stopPropagation();
                                        // Perform search, treating input as literal string (regex: false, smart: false)
                                        var searchValue = this.value;
                                        api.column(colIdx).search(searchValue, false, false).draw();
                                        
                                        // Restore cursor position if the element is still focused
                                        if (document.activeElement === this) {{
                                            var cursorPos = this.selectionStart;
                                            this.focus();
                                            this.setSelectionRange(cursorPos, cursorPos);
                                        }}
                                    }});
                            }});
                        }},
                        rowCallback: function(row, data, index){{
                             var statusCell = data[2]; // Status is now at index 2 (Timestamp, URL, Status, ...)
                             var status = parseInt(statusCell) || 0;
                             $(row).removeClass('ok error redirect');
                            if (status >= 400) {{
                                $(row).addClass('error');
                            }} else if (status >= 300) {{
                                $(row).addClass('redirect');
                            }} else if (status === 200) {{
                                $(row).addClass('ok');
                            }}
                        }}
                    }});
                }});
            }});
            
            // Scroll buttons logic
            var scrollTopButton = document.getElementById("scrollTopBtn");
            var scrollBottomButton = document.getElementById("scrollBottomBtn");
            var pageBody = document.body;
            var pageDocumentElement = document.documentElement;

            window.onscroll = function() {{scrollFunction()}};

            function scrollFunction() {{
                // Show scrollTopBtn if scrolled down, hide if near the top
                if (scrollTopButton) {{
                    if (pageBody.scrollTop > 30 || pageDocumentElement.scrollTop > 30) {{
                        scrollTopButton.style.display = "block";
                    }} else {{
                        scrollTopButton.style.display = "none";
                    }}
                }}

                // Show scrollBottomBtn if not near the bottom, hide if at the bottom.
                // Also ensure it's shown if page is scrollable at all from the top
                if (scrollBottomButton) {{
                    let isPageScrollable = pageDocumentElement.scrollHeight > pageDocumentElement.clientHeight;
                    let isAtBottom = (window.innerHeight + window.scrollY) >= pageDocumentElement.offsetHeight - 30; // 30px buffer

                    if (isPageScrollable && !isAtBottom) {{
                        scrollBottomButton.style.display = "block";
                    }} else {{
                        scrollBottomButton.style.display = "none";
                    }}
                }}
            }}
            // Initial check in case the page loads scrolled or is too short to scroll
            scrollFunction();

            // Assign functions to window so inline onclick can find them
            window.scrollToTop = function() {{ 
                pageBody.scrollTop = 0; // For Safari
                pageDocumentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
            }};
            window.scrollToBottom = function() {{
                pageBody.scrollTop = pageDocumentElement.scrollHeight; // For Safari
                pageDocumentElement.scrollTop = pageDocumentElement.scrollHeight; // For Chrome, Firefox, IE and Opera
            }};
        </script>
    </body>
    </html>
    """

    with open(output_html_path, 'w', encoding='utf-8') as f:
        f.write(html_content)
    print(f"✅ Combined HTML report saved to {output_html_path}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Generate a combined HTML report for AU and NZ link checks.')
    parser.add_argument('--au-csv', default='au_link_check_results.csv', help='Path to the AU link check results CSV file.')
    parser.add_argument('--nz-csv', default='nz_link_check_results.csv', help='Path to the NZ link check results CSV file.')
    parser.add_argument('--output-html', default='combined_report.html', help='Path to save the combined HTML report.')
    args = parser.parse_args()

    generate_combined_html_report(args.au_csv, args.nz_csv, args.output_html)
